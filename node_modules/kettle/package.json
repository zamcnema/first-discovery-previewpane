{
  "name": "kettle",
  "description": "Declarative IoC-based framework for HTTP servers on node.js based on express",
  "version": "1.0.0-dev.20151113T234353Z.121c5db",
  "author": {
    "name": "The Fluid Project"
  },
  "bugs": {
    "url": "http://issues.fluidproject.org/browse/KETTLE"
  },
  "homepage": "http://wiki.fluidproject.org/display/fluid/Kettle",
  "dependencies": {
    "express": "~4.13.3",
    "body-parser": "~1.13.3",
    "cookie-parser": "~1.3.5",
    "express-session": "~1.11.3",
    "serve-static": "1.10.0",
    "ws": "~0.8.0",
    "infusion": "2.0.0-dev.20151113T224751Z.3ba00f2",
    "jsonlint": "1.6.0",
    "resolve": "~1.1.6",
    "node-uuid": "~1.4.0",
    "path-to-regexp": "0.1.7"
  },
  "devDependencies": {
    "node-jqunit": "~1.1.3",
    "grunt-shell": "0.6.4",
    "grunt-contrib-jshint": "0.9.0",
    "grunt-jsonlint": "1.0.4",
    "grunt-gpii": "1.0.0",
    "grunt": "0.4.5"
  },
  "license": "BSD-3-Clause",
  "keywords": [
    "infusion",
    "framework",
    "application",
    "fluid",
    "IoC",
    "express",
    "Inversion of Control",
    "MVC",
    "evented"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/fluid-project/kettle.git"
  },
  "main": "./kettle.js",
  "engines": {
    "node": ">=4.2.1"
  },
  "gitHead": "aa6410411e65a532fc9dabc3c044e9391649c554",
  "readme": "# Kettle\r\n\r\nKettle is an integration technology which promotes the expression of servers handling HTTP and WebSockets endpoints. \r\nWith a few exceptions, Kettle implements no primary functionality of its own, but aggregates the facilities of\r\n[express](http://expressjs.com/) and [ws](http://einaros.github.io/ws/), as well as middleware held in the wider [pillarjs](https://github.com/pillarjs)\r\n\"Bring your own HTTP Framework Framework\" ecosystem. Kettle applications can easily incorporate any express-standard middleware, as well as coexisting with standard express apps targeted at the same\r\nnode.js <a href=\"https://nodejs.org/api/http.html#http_class_http_server\"><code>http.Server</code></a>. Since Kettle applications are expressed declaratively, in the JSON format encoding [Infusion](https://github.com/fluid-project/infusion)'s component trees, it is possible to adapt existing\r\napplications easily, as well as inserting middleware and new handlers anywhere in the pipeline without modifying the original application's code. This makes\r\nKettle suitable for uses where application functionality needs to be deployed flexibly in a variety of different configurations.\r\n\r\nIn fact, Kettle's dependency on express itself is minimal, since the entirety of the Kettle request handling pipeline is packaged\r\nas a single piece of express-compatible middleware – Kettle could be deployed against any other consumer of middleware or even a raw node.js HTTP server.\r\n\r\n# Contents of this repository\r\n\r\n## Core Kettle implementation\r\n\r\nThis is packaged as Infusion [grades](http://docs.fluidproject.org/infusion/development/ComponentGrades.html) derived from [`kettle.server`](#kettle.server), [`kettle.request`](#kettle.request) and [`kettle.app`](#kettle.app). The first two of these exist in variants specialized both for plain\r\nHTTP (with the `.http` suffix) and for WebSockets (with the `.ws` suffix) – `kettle.app` does not specialize.\r\n\r\n## Contents - Testing\r\n\r\nAs well as the integration technology implementing Kettle itself, this repository also contains functionality helpful for testing HTTP and WebSockets\r\nservers written in arbitrary technologies. This is accessed by running `kettle.loadTestingSupport()` after having called `require(\"kettle\")`. Kettle testing \r\nsupport allows HTTP and WebSockets client requests to be packaged as [Infusion](https://github.com/fluid-project/infusion) components, suitable for use with Infusion's\r\n[IoC Testing Framework](http://docs.fluidproject.org/infusion/development/IoCTestingFramework.html). Any user of Kettle's testing support needs to have [node-jqunit](https://github.com/fluid-project/node-jqunit)\r\nregistered as a member of their own project's `devDependencies` in their own package.json.\r\n\r\nKettle runs on [node.js](https://nodejs.org) version 4.x (see [package.json](package.json) for current dependency profile).\r\n\r\n## Contents - DataSources\r\n\r\nThe Kettle repository also contains a few implementations of the simple `DataSource` contract for read/write access to data with a simple semantic (broadly the same as that\r\nencoded in [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) although the current DataSource semantic does not provide explicitly for deletion). See the documentation section\r\non [DataSources](#datasources) for details of this contract, the available implementations and how to use them.\r\n\r\nThis repository contains DataSource implementations suitable for HTTP endpoints (with a particular variety specialised for accessing CouchDB databases with CRUDlike semantics) as well as the filesystem, with\r\nan emphasis on JSON payloads.\r\n\r\n# Getting Started and Community\r\n\r\n## Installation instructions\r\n\r\nFirstly, install node and npm by running a standard installer from [node.js](https://nodejs.org). Clone this repository and then run `npm install`.\r\n\r\n## Issue Tracking\r\n\r\nIssue tracking is at http://issues.fluidproject.org/browse/KETTLE .\r\n\r\n## IRC\r\n\r\nVisit `#fluid-work` on EFNet – community resources are linked at [Fluid's IRC Channels](https://wiki.fluidproject.org/display/fluid/IRC+Channel).\r\n\r\n## Mailing list\r\n\r\nContact us on the [fluid-work](https://wiki.fluidproject.org/display/fluid/Mailing+Lists) mailing list with any problems or comments.\r\n\r\n## Uses of Kettle and related projects\r\n\r\nThe primary user of Kettle is the [GPII](http://gpii.net/)'s autopersonalisation infrastructure, held at [GPII/universal](https://github.com/GPII/universal). Kettle is used\r\nto provide a flexible means of deploying the GPII's \"Flow Manager\" and related components distributed across multiple local and remote installations.\r\n\r\nA closely related project to Kettle is [gpii-express](https://github.com/GPII/gpii-express) which is used in other GPII projects such as the [terms registry](https://github.com/GPII/common-terms-registry) and\r\n[unified listing](https://github.com/GPII/ul-api). This is similar in architecture to Kettle (wrapping express primitives such as servers and requests into dynamically constructed Infusion components) \r\nbut slightly different in emphasis – \r\n\r\n* gpii-express allows independently mounted application units with nested routing, in the Express 4.x style – whereas Kettle is currently limited to flat Express 3.x-style routing\r\n* Kettle incorporates support for WebSockets endpoints, whereas gpii-express does not\r\n* Kettle incorporates support for DataSources (see [DataSources](#datasources) )\r\n\r\nThe request-handling architecture for gpii-express and Kettle is quite similar and the projects will probably converge over time. gpii-express currently already depends on Kettle to get access to its\r\nHTTP [testing](#testing) support.\r\n\r\n# Documentation\r\n\r\nDocumentation and sample code for working with Kettle now follow:\r\n\r\n## Kettle applications\r\n\r\nThe top-level structure of a Kettle applications can be described by a \"config\" file in JSON format. A Kettle \"config\"\r\ndescribes the configuration of a number of \"Kettle apps\" ([grade](http://docs.fluidproject.org/infusion/development/ComponentGrades.html) `kettle.app`) hosted in a number of \"Kettle servers\" (grade `kettle.server`). \r\nThe config JSON file represents an Infusion [component tree](http://docs.fluidproject.org/infusion/development/HowToUseInfusionIoC.html). If you aren't familiar\r\nwith the syntax and meaning of component trees, it is a good idea to browse the documentation, tutorials and examples at the \r\nInfusion [documentation site](http://docs.fluidproject.org/infusion/development/). Kettle components are currently derived from\r\nthe base grade `fluid.component`, so you can ignore for these purposes the parts of the Infusion documentation relating to model and view components.\r\n\r\n## A simple Kettle application\r\n\r\nIn this section, we will construct a simple Kettle application within JavaScript code, to produce a self-contained example. You can find and try out this\r\nsame application represented in two forms in the [examples/simpleConfig](examples/simpleConfig) directory. \r\n\r\n```javascript\r\n\r\nfluid.defaults(\"examples.simpleConfig\", {\r\n    gradeNames: \"fluid.component\",\r\n    components: {\r\n        server: {\r\n            type: \"kettle.server\",\r\n            options: {\r\n                port: 8081,\r\n                components: {\r\n                    app: {\r\n                        type: \"kettle.app\",\r\n                        options: {\r\n                            requestHandlers: {\r\n                                getHandler: {\r\n                                    \"type\": \"examples.simpleConfig.handler\",\r\n                                    \"route\": \"/handlerPath\",\r\n                                    \"method\": \"get\"\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\nfluid.defaults(\"examples.simpleConfig.handler\", {\r\n    gradeNames: \"kettle.request.http\",\r\n    invokers: {\r\n        handleRequest: \"examples.simpleConfig.handleRequest\"\r\n    }\r\n});\r\n\r\nexamples.simpleConfig.handleRequest = function (request) {\r\n    request.events.onSuccess.fire({\r\n        message: \"GET request received on path /handlerPath\"\r\n    });\r\n};\r\n\r\n// Construct the server using the above config\r\nexamples.simpleConfig();\r\n```\r\n\r\nThe JSON \"config\" form of the application itself is held at [examples/simpleConfig/examples.simpleConfig.json](./examples/simpleConfig/examples.simpleConfig.json), \r\nwhich encodes the same information as in the first `fluid.defaults` call above. The definitions for request handlers such as `examples.simpleConfig.handler` and\r\n`examples.simpleConfig.handleRequest`, which in our sample are held in [examples/simpleConfig/simpleConfig-config-handler.js](./examples/simpleConfig/simpleConfig-config-handler.js), \r\nalways need to be supplied in standard `.js` files required by the application – although future versions of Kettle\r\nmay allow the defaults for the handler grade to be encoded in JSON. Consult the Infusion framework documentation on [grades](http://docs.fluidproject.org/infusion/development/ComponentGrades.html) if\r\nyou are not familiar with this kind of configuration.\r\n\r\nYou can try out these samples in [examples/simpleConfig](examples/simpleConfig) by, for example, from that directory, typing `node simpleConfig-config-driver.js`. The last line of the driver files\r\nload a common module, `simpleConfig-client.js` which tests the server by firing an HTTP request to it and logging the payload – this uses one of the HTTP client drivers taken from Kettle's\r\n[testing](#kettle-testing-framework) definitions. Later on, we will see how to issue formal test fixtures against this application by using the [Kettle testing framework](#kettle-testing-framework).\r\n\r\n## Starting a Kettle application\r\n\r\nKettle applications can be started in a variety of ways, both programmatically and from the command line - as well as easily embedded into other applications, be they Infusion component trees or raw Express apps.\r\n\r\n### Starting a Kettle config programmatically\r\n\r\nKettle includes a driver function, `kettle.config.loadConfig` which will load and run a Kettle application defined as a JSON file in the filesystem. It accepts an `options` structure which includes the\r\nfollowing fields:\r\n\r\n|Member name| Type | Description |\r\n|-----------|------|-------------|\r\n|`configName`| `String` | The name of the config (the bare filename, minus any extension) which is to be loaded|\r\n|`configPath`| `String` | The directory holding the config. This path may start with a symbolic module reference, e.g. of the form `%kettle`, to a module which has been registered using Infusion's module API [`fluid.module.register`](http://docs.fluidproject.org/infusion/development/NodeAPI.html#fluid-module-register-name-basedir-modulerequire-)|\r\n\r\n`kettle.config.loadConfig` will return the (Infusion) component instance of the initialised application. You could use this, for example, to terminate the application using its ``destroy()`` method.\r\n\r\nAn alternative to `kettle.config.loadConfig` is `kettle.config.createDefaults`. This accepts the same arguments but simply loads the config as a [grade](http://docs.fluidproject.org/infusion/development/ComponentGrades.html)\r\nrather than instantiating it as well. The return value from `kettle.config.loadConfig` is the grade name of the application. You can construct this application later by use of Infusion's [`invokeGlobalFunction`](http://docs.fluidproject.org/infusion/development/CoreAPI.html#fluid-invokeglobalfunction-functionpath-args-) API, or else\r\nembed it in a wider application as a subcomponent.\r\n\r\n### Starting a Kettle config from the command line\r\n\r\nKettle includes a top-level driver file named `init.js` which will accept values from the command line and the environment variable ``NODE_ENV`` in order to determine which application config to start.\r\nFor example, from Kettle's top-level directory you can run\r\n\r\n```\r\n    node init.js <configPath> [<configName>]\r\n````\r\n\r\nThe `configPath` argument is required - its meaning is as given in the `configPath` option to `kettle.config.loadConfig` call described in the previous section.\r\n\r\nThe `configName` argument is optional. If this value is not supplied at the command line, it will be read from the environment variable ``NODE_ENV``. The meaning is as given in the `configName` option to `kettle.config.loadConfig` described in the previous section.\r\n\r\nFor example, you can start the sample app from the [previous section](#a-simple-kettle-application) by running\r\n```\r\n   node init.js examples/simpleConfig examples.simpleConfig\r\n```\r\nfrom the root directory of a Kettle checkout.\r\n\r\n## Structure of a Kettle config\r\n\r\nIn the previous section, we saw a [simple example](./examples/simpleConfig/simpleConfig-config.json) of a JSON-formatted Kettle config, which declaratively encodes a Kettle application structure.\r\nIn this section we describe the top-level members of this structure, and in the next secion we'll look at the containment structure in terms of [grades](http://docs.fluidproject.org/infusion/development/ComponentGrades.html).\r\nIn the rest of this document we'll describe the options accepted by the various grades which make up a Kettle application (`kettle.server`, `kettle.app`, `kettle.middleware` and `kettle.request`). The structure of our\r\nminimal application will serve as a general template – the full definition of a Kettle application consists of a config, ***plus*** definitions of request handler grades ***plus*** implementations of request handler functions.\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Top-level members of a Kettle \"config\" configuration file</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Member</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>type</code></td>\r\n            <td><code>String</code> (grade name)</td>\r\n            <td>The type name for this config. This should be a fully-qualified grade name – it is suggested that it agree with the file name of the config file without the <code>.json</code> extension.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>options</code></td>\r\n            <td><code>Object</code> (component options)</td>\r\n            <td>The options for the application structure. These should start with the application's <code>gradeNames</code> which will usually just be <code>fluid.component</code>, and then continue with <code>components</code> designating the\r\n            next level of containment of the application, the <code>kettle.server</code> level – see the next section on <a href=\"#containent-structure-of-a-kettle-application\">containment structure of a Kettle application</a> for the full structure</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>mergeConfigs</code> (optional)</td>\r\n            <td><code>String/Array of String</code></td>\r\n            <td>A filename (or array of these) of other config files which are to be included into this application. These names may begin with a <a href=\"http://docs.fluidproject.org/infusion/development/NodeAPI.html#node-js-module-apis\">module-relative path</a>\r\n            such as <code>%kettle</code> or else will be interpreted as \r\n            paths relative to this config's location in the filesystem. Each filename listed here will be loaded and resolved as a grade and then merged with the \r\n            structure of this config (via an algorithm similar to <a href=\"https://api.jquery.com/jquery.extend/\">jQuery.extend</a> – note that because of a current Infusion framework bug <a href=\"https://issues.fluidproject.org/browse/FLUID-5614\">FLUID-5614</a>, \r\n            all of the semantics of nested <a href=\"http://docs.fluidproject.org/infusion/development/OptionsMerging.html\">options merging</a> will\r\n            not be respected and the merging will occur in a simple-minded way below top level)</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>loadConfigs</code> (optional)</td>\r\n            <td><code>String/Array of String</code></td>\r\n            <td>A filename (or array of these) of other config files which will be loaded before this config is interpreted. These names may begin with a <a href=\"http://docs.fluidproject.org/infusion/development/NodeAPI.html#node-js-module-apis\">module-relative path</a>\r\n            such as <code>%kettle</code> or else will be interpreted as \r\n            paths relative to this config's location in the filesystem. Each filename listed here will be loaded and resolved as a grade. The workflow is similar to that with <code>mergeConfigs</code>, only the grades represented in <code>loadConfigs</code>\r\n            will not be automatically merged with the current config as parent grades. Instead, the user is free to refer to them as required - for example as the <code>type</code> or <code>gradeNames</code> of a <a href=\"http://docs.fluidproject.org/infusion/development/SubcomponentDeclaration.html\">subcomponent</a></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>require</code> (optional)</td>\r\n            <td><code>String/Array of String</code></td>\r\n            <td>A <a href=\"https://nodejs.org/api/modules.html\">module identifier</a> (or array of these) that will be loaded when this config is loaded. These modules will be loaded as if by the standard node.js API\r\n            <a href=\"https://nodejs.org/api/modules.html\"><code>require</code></a> operating from the config's directory (the <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_the_global_folders>global folder rules</a> will be ignored). \r\n            These names may begin with a <a href=\"http://docs.fluidproject.org/infusion/development/NodeAPI.html#node-js-module-apis\">module-relative path</a> such as <code>%kettle</code> to indicate a path relative to a module registered with Infusion.</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n\r\n## Containment structure of a Kettle application\r\n\r\nThe overall structure of a Kettle application (a \"config\") shows a 4-level pattern:\r\n\r\n* At top level, the application container – this has the simple grade `fluid.component` and does not carry any functionality – it is simply used for grouping the definitions at the next level\r\n    * At 2nd level, one or more Kettle servers – these have the grade `kettle.server` – in the case there is just one server it is conventionally named `server`\r\n        * At 3rd level, one more Kettle apps – these have the grade `kettle.app` – this is the level at which independently mountable segments of applications are grouped (an app is a grouping of handlers)\r\n            * At 4th level, one or more Kettle request handlers – these have the grade `kettle.request` – each of these handles one endpoint (HTTP or WebSockets) routed by URL and request method\r\n            \r\nThis expression is much more verbose in simple cases than the traditional raw use of express apps, but in larger and more complex applications this verbosity is amortised, with the ability to easily\r\ncustomise and reassort groups of handlers and servers from application to application.\r\n\r\nNote that the containment relationships between the top 3 levels need not be direct – servers may be nested any number of levels below the config root, and apps may be nested any number of \r\nlevels below a server. However, request handlers must be defined as direct children of their parent apps, in the options section named `requestHandlers`. \r\n\r\n<a id=\"kettle.server\"></a>\r\n\r\n### Configuration options for a `kettle.server`\r\n\r\nThe `kettle.server` grade accepts the following options which can usefully be configured by the user. Naturally by virtue of being a `fluid.component` there\r\nare numerous other parts of its lifecycle which can be customised, but these are the options principally supported for user configuration:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Supported configurable options for a </code>kettle.server</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>members.expressApp</code></td>\r\n            <td><a href=\"http://expressjs.com/4x/api.html#app\"><code>express</code></a></td>\r\n            <td>The express <a href=\"http://expressjs.com/4x/api.html#app\">application</a> which this server is to be bound to. If this option is not overriden, the server will automatically construct one using the <code>express()</code> constructor.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>members.httpServer</code></td>\r\n            <td><a href=\"https://nodejs.org/api/http.html#http_class_http_server\"><code>http.Server</code></a></td>\r\n            <td>The node.js <a href=\"https://nodejs.org/api/http.html#http_class_http_server\"><code>HTTP server</code></a> which this server is to be bound to. If this option is not overriden, the server will use the one extracted from the <code>expressApp</code> member</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>port</code></td>\r\n            <td><code>Number</code></td>\r\n            <td>The port number which this server is to listen on. Defaults to 8081.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>rootMiddleware</code></td>\r\n            <td><a href=\"#middlewareSequence\"><code>middlewareSequence</code></a></td>\r\n            <td>The group of middleware which is to be executed for every request handled by this server</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>components.middlewareHolder</code></td>\r\n            <td><code>Component</code></a></td>\r\n            <td>A plain component container for middleware that is intended to be resolvable throughout the server's component tree</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onListen</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>An event fired once this server has started listening on its port. Fired with one argument, the server component itself</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.beforeStop</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>An event fired just before this server is about to be stopped. This is an opportunity to clean up any resource (e.g. close any open sockets). Fired with one argument, the server component itself</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onStopped</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>An event fired after the server is stopped and the HTTP server is no longer listening. Fired with one argument, the server component itself</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onContributeMiddleware</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>This event is useful for authors trying to integrate with 3rd-party express applications. This is a useful lifecycle point, before Kettle registers its own middleware to the express application,\r\n            for an external integrator to register their own middleware first, e.g. using <code>app.use</code>. Fired with one argument, the server component itself – typically only <code>that.expressApp</code> will be of interest to the listener</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onContributeMiddleware</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>This event is useful for authors trying to integrate with 3rd-party express applications. This is a useful lifecycle point, before Kettle registers its own rout handlers to the express application,\r\n            for an external integrator to register their own rout handlers first, e.g. using <code>app.get</code> etc.. Fired with one argument, the server component itself – typically only <code>that.expressApp</code> will be of interest to the listener</code></td>\r\n        </tr>      \r\n    </tbody>\r\n</table>\r\n\r\n### Configuration options for a `kettle.server.ws`\r\n\r\nA WebSockets-capable server exposes all of the configurable options supported by a `kettle.server` in addition to the ones in the table below:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Supported configurable options for a </code>kettle.server.ws</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>wsServerOptions</code></td>\r\n            <td><code>Object</code></td>\r\n            <td>Any options to be forwarded to the constructor of the <a href=\"https://github.com/websockets/ws/blob/master/doc/ws.md#new-wsserveroptions-callback\"><code>ws.Server</code></a>. Note that after construction, this server will\r\n            be available as the top-level member named <code>wsServer</code> on the overall component.</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n<a id=\"kettle.app\"></a>\r\n\r\n## Registering and implementing a request handler\r\n\r\nRequest handlers are registered in the `requestHandlers` section of the options of a `kettle.app` – see the [sample app](#a-simple-kettle-application) for positioning of this component in the\r\ncontainment structure. This consists of a free hash of `handlerName` strings to `handlerRecord` structures.\r\n\r\n###Structure of the `requestHandlers` option of a `kettle.app`\r\n```javascript\r\n{\r\n<handlerName> : <handlerRecord>,\r\n<handlerName> : <handlerRecord>,\r\n...\r\n}\r\n```\r\n\r\nNote that the `handlerName`s are simply free strings and have no function other than to uniquely name the handler in the context of its app. These strings exist to allow easy alignment when \r\nmultiple apps are merged together from different sources to produce combined apps.\r\n\r\n### Structure of the `handlerRecord` structure\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Members of an <code>handlerRecord</code> entry within the <code>requestHandlers</code> block of a <code>kettle.app</code> component</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Member</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>type</code></td>\r\n            <td><code>String</code></td>\r\n            <td>The name of a request handling grade, which must be descended from <code>kettle.request</code>. If you supply the <code>method</code> field, your grade must be descended from <code>kettle.request.http</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>route</code></td>\r\n            <td><code>String</code></td>\r\n            <td>An express-compatible <a href=\"http://expressjs.com/guide/routing.html\">routing</a> string, expressing the range of HTTP paths to be handled by this handler, together with any named parameters and query parameters\r\n            that should be captured. The exact syntax for route matching is documented more precisely at <a href=\"https://github.com/pillarjs/path-to-regexp\">pillarjs</a></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>prefix</code> (optional)</td>\r\n            <td><code>String</code></td>\r\n            <td>A routing prefix to be prepended to this handler's <code>route</code>. The prefix plus the route expression must match the incoming request in order for this handler to be activated – \r\n            but if it is, it will only see the portion of the URL matched by <code>route</code> in the member <code>request.req.url</code>. The entire incoming URL will remain visible in <code>request.req.originalUrl</code> – \r\n            this is the same behaviour as express.js <a href=\"http://expressjs.com/api.html#app.use\">routing system</a>. It is primarily useful when using <a href=\"#thing\">static middleware</a> which will compare the\r\n            <code>req.url</code> value with the filesystem path relative to its mount point.\r\n        </tr>\r\n        \r\n        <tr>\r\n            <td><code>method</code> (optional)</td>\r\n            <td><code>String</code> value – one of the valid <a href=\"https://github.com/nodejs/node/blob/master/deps/http_parser/http_parser.h#L88\">HTTP methods</a> supported by node.js, expressed in lower case, or else a comma-separated \r\n            sequence of such values.\r\n            </td>\r\n            <td>The HTTP request type(s) which this handler will match. <code>method</code> is omitted in the \r\n            case that the request handling grade is not descended from <code>kettle.request.http</code> – the only currently supported requests of that type are WebSockets requests descended from <code>kettle.request.ws</code> \r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n### How to implement a request handler\r\n\r\nA handler for a particular request must have a [grade](http://docs.fluidproject.org/infusion/development/ComponentGrades.html) registered with Infusion whose name\r\nmatches the `type` field in the `handlerRecord` structure just described. The parent grades of this grade must be consistent with the the request you expect to handle – \r\ndescended from `kettle.request.http` in the case of an HTTP request, or `kettle.request.ws` in the case of a WebSockets request. In addition, the grade must define\r\n(at minimum) an [invoker](http://docs.fluidproject.org/infusion/development/Invokers.html) named `handleRequest`. This invoker will be called by Kettle when your route\r\nis matched, and be supplied a single argument holding the ***request object***, an object whose grade is your request handler's grade, which the framework has\r\nconstructed to handle the request.\r\n \r\nWe duplicate the definitions from the [sample application](#a-simple-kettle-application) in order to show a minimal request handler grade and request handler function:\r\n\r\n```javascript\r\nfluid.defaults(\"examples.simpleConfig.handler\", {\r\n    gradeNames: \"kettle.request.http\",\r\n    invokers: {\r\n        handleRequest: \"examples.simpleConfig.handleRequest\"\r\n    }\r\n});\r\n\r\nexamples.simpleConfig.handleRequest = function (request) {\r\n    request.events.onSuccess.fire({\r\n        message: \"GET request received on path /handlerPath\"\r\n    });\r\n};\r\n```\r\n\r\nIn the next section we will talk more about request (handler) objects, the members you can expect on them, and how to use them.\r\n\r\n<a id=\"kettle.request\"></a>\r\n\r\n## Request components\r\n\r\nA ***request component*** is constructed by Kettle when it has determined the correct [handler record](#registering-and-implementing-a-request-handler) which matches\r\nthe incoming request. This request component will be usefully populated with material drawn from the request and node.js initial process of handling it. It also contains\r\nvarious elements supplied by Kettle in order to support you in handling the request. You can add any further material that you like to the request object by adding\r\nentries to its grade definition, of any of the types supported by Infusion's [component configuration options](http://docs.fluidproject.org/infusion/development/ComponentConfigurationOptions.html).\r\nHere we will document the standard members that are placed there by Kettle for the two standard request types which are supported, `kettle.request.http` and `kettle.request.ws`.\r\n\r\n### Members defined by the Kettle framework at top-level on a request component\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Members defined by default at top-level on a (HTTP) request component</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Member</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>req</code></td>\r\n            <td><a href=\"https://nodejs.org/api/http.html#http_http_incomingmessage\"><code>http.IncomingMessage</code></a></td>\r\n            <td>The request object produced by node.js – this is the value which is commonly referred to as <a href=\"http://expressjs.com/4x/api.html#req\"><code>req</code></a> in the standard express <a href=\"http://expressjs.com/guide/using-middleware.html\">middleware pattern</a></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>res</code> (only for <code>kettle.request.http</code>)</td>\r\n            <td><a href=\"https://nodejs.org/api/http.html#http_class_http_serverresponse\"><code>http.ServerResponse</code></a></td>\r\n            <td>The response object produced by node.js – this is the value which is commonly referred to as <a href=\"http://expressjs.com/4x/api.html#res\"><code>res</code></a> in the standard express <a href=\"http://expressjs.com/4x/api.html#req\">middleware pattern</a></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onSuccess</code> (only for <code>kettle.request.http</code>)</td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>A standard <a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\">Infusion Event</a> which should be fired if the request is to produce a response successfully. The event argument will produce the response body – if it is of type <code>Object</code>, it will be JSON-encoded.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onError</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>A standard <a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\">Infusion Event</a> which should be fired if the request is to send an error response. \r\n            For a request of type <code>kettle.request.http</code>, the argument to the event must be an <code>Object</code> with at least\r\n            a field <code>message</code> of type <code>String</code> holding the error message to be returned to the client. The argument can also include a member <code>statusCode</code> of type <code>Number</code> holding the HTTP status code to accompany the error – \r\n            if this is not supplied, it will default to 500.\r\n        </tr>\r\n        <tr>\r\n            <td><code>handlerPromise</code> (only for <code>kettle.request.http</code>)</td>\r\n            <td><code>Promise</code></td>\r\n            <td>This promise is a proxy for the two events <code>onSuccess</code> and <code>onError</code>, packaged as a <a href=\"https://www.promisejs.org/\">Promise</a>. This promise exposes methods <code>resolve</code> and <code>reject</code>\r\n            which forward their arguments to <code>onSuccess</code> and <code>onError</code> respectively. In addition, the promise exposes a <code>then</code> method which accepts two callbacks which can be used to listen to these event firings\r\n            respectively. Note that this promise is not compliant with any particular specification for promises, including ES6, A+, etc. – in the language of those specifications, it is simply a <code>thenable</code> which also includes \r\n            the standard resolution methods <code>resolve</code> and <code>reject</code>. Implementation at <a href=\"https://github.com/fluid-project/infusion/blob/master/src/framework/core/js/FluidPromises.js#L21\">FluidPromises.js</a>.\r\n            </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onSuccess</code> (only for <code>kettle.request.http</code>)</td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>A standard <a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\">Infusion Event</a> which should be fired if the request is to produce a response successfully. The event argument will produce the response body – if it is of type <code>Object</code>, it will be JSON-encoded.</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\nNote that, in return, the Kettle request component will be marked onto the node.js request object so that it can easily be retrieved from standard middleware, etc. – it will be available as `req.fluidRequest` where `req` is the\r\nrequest object described in the table above. More details follow on middleware in the section [working with middleware](working-with-middleware).\r\n\r\n### Members defined by the Kettle framework at top-level on a WebSockets request component\r\n\r\nWebSockets communications in a Kettle application are mediated by the [ws](https://github.com/websockets/ws) WebSockets library – you should get familiar with the documentation for\r\nthat library if you intend to use this functionality significantly. It is also worth spending some time familiarising yourself with at least some of the `ws` implementation code since there are several\r\naspects not properly covered by the documentation.\r\n\r\nThe request component for a WebSockets request, derived from the grade `kettle.request.ws` includes the members in the above table which are not marked as\r\n`kettle.request.http` only, as well as several more members described in the following table:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Members defined by default at top-level on a WebSockets request component</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Member</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>ws</code></td>\r\n            <td><a href=\"https://github.com/websockets/ws/blob/master/doc/ws.md#class-wswebsocket\"><code>ws.WebSocket</code></a></td>\r\n            <td>The <code>ws.WebSocket</code> advertised by the <a href=\"https://github.com/websockets/ws\"><code>ws</code></a> WebSockets library as allocated to handle one end of an established WebSockets connection. This will be of the variety\r\n            referred to in the <code>ws</code> docs as \"a WebSocket constructed by a Server\".</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onReceiveMessage</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>A standard <a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\">Infusion Event</a> which is fired by the framework when a message is received from the client\r\n            at the other end of the WebSockets connection. The arguments to the event are <code>(that, payload)</code> where <code>that</code> represents this request component itself, and <code>payload</code> represnts\r\n            the payload sent by the client. If the <code>receiveMessageJSON</code> option is set to <code>true</code> for this component (the default), the payload will have been decoded as JSON.\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onSendMessage</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>A standard <a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\">Infusion Event</a> which can be fired by the implementor of the request handler when they want to send a message to the client.\r\n            This event expects to receive just a single argument, the message payload. If the <code>sendMessageJSON</code> option is set to <code>true</code> for this component (the default), the payload will be encoded by the framework as JSON.\r\n        </tr>\r\n        <tr>\r\n            <td><code>events.onError</code></td>\r\n            <td><a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\"><code>Event</code></a></td>\r\n            <td>A standard <a href=\"http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html\">Infusion Event</a> which should be fired if the request is to end an error response.\r\n            This event has the same name as the one fired by a <code>kettle.request.http</code> but the behaviour and semantic is different. Rather than sending an HTTP error response, the framework instead\r\n            emits a WebSockets  event of type <code>error</code>. Because of this, the <code>statusCode</code> field of the event argument should not be used. However, it is recommended that the event payload\r\n            still includes a field <code>message</code> of type <code>String</code> holding the error message to be returned to the client, as well as a boolean member <code>isError</code> with the value <code>true</code>.\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n### Working with middleware\r\n\r\nThe most crucial structuring device in the expressjs (or wider pillarjs) community is known as ***[middleware](http://expressjs.com/guide/using-middleware.html)***. In its most basic form, a piece of middleware is simply a function with the following signature:\r\n\r\n    middleware(req, res, next)\r\n    \r\nThe elements `req` and `res` have been described in the section on [request components](#members-defined-by-the-kettle-framework-at-top-level-on-a-request-component). The element `next` is a callback provided\r\nby the framework to be invoked when the middleware has completed its task. This could be seen as a form of [continuation passing style](https://en.wikipedia.org/wiki/Continuation-passing_style) with 0 arguments – \r\nalthough only in terms of control flow since in general middleware has its effect as a result of side-effects on the request and response. In express, middleware are typically accumulated in arrays or groups of arrays\r\nby directives such as `app.use`. If a piece of middleware completes without error, it will invoke the `next` callback with no argument, which will signal that control should pass to the next middleware in the\r\ncurrent sequence, or back to the framework if the sequence is at an end. Providing an argument to the callback `next` is intended to signal an error\r\nand the framework will then abort the middleware chain and propagate the argument, conventionally named `err`, to an error handler. This creates an analogy with executing \r\n[promise sequences](http://stackoverflow.com/questions/24586110/resolve-promises-one-after-another-i-e-in-sequence) which we will return to when we construct [middleware components](#defining-and-registering-middleware-components).\r\n\r\nIn Kettle, middleware can be scheduled more flexibly than by simply being accumulated in arrays – the priority of a piece of middleware can be freely adjusted by assigning it a [Priority](http://docs.fluidproject.org/infusion/development/Priorities.html)\r\nas seen in many places in the Infusion framework, and so integrators can easily arrange for middleware to be inserted in arbitrary positions in already existing applications.\r\n\r\nMiddleware is accumulated at two levels in a Kettle application – firstly, overall middleware is accumulated at the top level of a `kettle.server` in an option named `rootMiddleware`. This is analogous to express\r\n[app-level middleware](http://expressjs.com/guide/using-middleware.html#middleware.application) registered with `app.use`. Secondly, individual request middleware\r\ncan be attached to an individual `kettle.request` in its options at `requestMiddleware`. This is analogous to express [router-level middleware](http://expressjs.com/guide/using-middleware.html#middleware.router).\r\nThe structure of these two options areas is the same, which we name `middlewareSequence`. When the request begins to be handled, the framework\r\nwill execute the following in sequence:\r\n\r\n* The root middleware attached to the `kettle.server`\r\n* The request middleware attached to the resolved `kettle.request` component\r\n* The actual request handler designated by the request component's invoker `handleRequest`\r\n\r\nIf any of the middleware in this sequence signals an error, the entire sequence will be aborted and an error returned to the client.\r\n\r\n### Structure of entries in a `middlewareSequence`\r\n\r\nA `middlewareSequence` is a free hash of keys, considered as **namespaces** for the purpose of resolving [Priorities](http://docs.fluidproject.org/infusion/development/Priorities.html) onto\r\nrecords of type `middlewareEntry`:\r\n\r\n```javascript\r\n{\r\n    <middlewareKey> : <middlewareEntry>,\r\n    <middlewareKey> : <middlewareEntry>,\r\n...\r\n}\r\n```\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Members of an <code>middlewareEntry</code> entry within the <code>middlewareSequence</code> block of a component (<code>rootMiddleware</code> for <code>kettle.server</code> or <code>requestMiddleware</code> for <code>kettle.request</code>)</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Member</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>middleware</code></td>\r\n            <td><code>String</code> (<a href=\"http://docs.fluidproject.org/infusion/development/IoCReferences.html\">IoC Reference</a>)</td>\r\n            <td>An IoC reference to the middleware component which should be inserted into the handler sequence. Often this will be qualified by the context <code>{middlewareHolder}</code> – e.g. <code>{middlewareHolder}.session</code> – to reference the core\r\n            middleware collection attached to the <code>kettle.server</code> but middleware could be resolved from anywhere visible in the component tree. This should be a reference to a component descended from the grade <code>kettle.middleware</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>priority</code> (optional)</td>\r\n            <td><code>String</code> (<a href=\"http://docs.fluidproject.org/infusion/development/Priorities.html\">Priority</a>)</td>\r\n            <td>An encoding of a priority relative to some other piece of middleware within the same group – will typically be <code>before:middlewareKey</code> or <code>after:middlewareKey</code> for the <code>middlewareKey</code> of some\r\n            other entry in the group</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n### Defining and registering middleware components\r\n\r\nA piece of Kettle middleware is derived from grade `kettle.middleware`. This is a very simple grade which defines a single invoker named `handle` which accepts one argument, a `kettle.request`, and returns a \r\npromise representing the completion of the middleware. Conveniently a `fluid.promise` implementation is available in the framework, but you can return any variety of `thenable` that you please. Here is a skeleton,\r\nmanually implemented middleware component:\r\n\r\n```javascript\r\nfluid.defaults(\"examples.customMiddleware\", {\r\n    gradeNames: \"kettle.middleware\",\r\n    invokers: {\r\n        handle: \"examples.customMiddleware.handle\"\r\n    }\r\n});\r\n\r\nexamples.customMiddleware.handle = function (request) {\r\n    var togo = fluid.promise();\r\n    if (request.req.params.id === 42) {\r\n        togo.resolve();\r\n    } else {\r\n        togo.reject({\r\n            isError: true,\r\n            statusCode: 401,\r\n            message: \"Only the id 42 is authorised\"\r\n        });\r\n    }\r\n    return togo;\r\n};\r\n```\r\n\r\nThe framework makes it very easy to adapt any standard express middleware into a middleware component by means of the adaptor grade `kettle.plainMiddlware`. This accepts any standard express\r\nmiddleware as the option named `middleware` and from it fabricates a `handle` method with the semantic we just saw earlier. Any options that the middleware accepts can be forwarded to it from\r\nthe component's options. Here is an example from the framework's own `json` middleware grade:\r\n\r\n```javascript\r\nkettle.npm.bodyParser = require(\"body-parser\");\r\n\r\nfluid.defaults(\"kettle.middleware.json\", {\r\n    gradeNames: [\"kettle.plainMiddleware\"],\r\n    middlewareOptions: {}, // see https://github.com/expressjs/body-parser#bodyparserjsonoptions\r\n    middleware: \"@expand:kettle.npm.bodyParser.json({that}.options.middlewareOptions)\"\r\n});\r\n```\r\n\r\nConsult the Infusion documentation on the [compact format for expanders](http://docs.fluidproject.org/infusion/development/ExpansionOfComponentOptions.html#compact-format-for-expanders) if you\r\nare unfamiliar with this syntax for designating elements in component options which arise from function calls.\r\n\r\n### Built-in standard middleware bundled with Kettle\r\n\r\nHere we describe the built-in middleware supplied with Kettle, which is mostly sourced from standard middleware in the [express](http://expressjs.com/) and [pillarjs](https://github.com/pillarjs)\r\ncommunities. You can consult the straightforward implementations in [KettleMiddleware.js](https://github.com/fluid-project/kettle/tree/master/lib/KettleMiddleware.js) for suggestions for how\r\nto implement your own.\r\n\r\n<div style=\"font-size: smaller\">\r\n<table>\r\n<thead>\r\n<tr><th>Grade name</th><th>Middleware name</th><th>Description</th><th>Accepted options</th><th>Standard IoC Path</th></tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n    <td><code>kettle.middleware.json</code></td>\r\n    <td><a href=\"https://github.com/expressjs/body-parser\">expressjs/body-parser</a></td>\r\n    <td>Parses JSON request bodies, possibly with compression.</td>\r\n    <td><code>middlewareOptions</code>, forwarded to <a href=\"https://github.com/expressjs/body-parser#bodyparserjsonoptions\"<code>bodyParser.json(options)</code></a></td>\r\n    <td><code>{middlewareHolder}.json</code></td>\r\n</tr>\r\n<tr>\r\n    <td><code>kettle.middleware.urlencoded</code></td>\r\n    <td><a href=\"https://github.com/expressjs/body-parser\">expressjs/body-parser</a></td>\r\n    <td>Applies URL decoding to a submitted request body</td>\r\n    <td><code>middlewareOptions</code>, forwarded to <a href=\"https://github.com/expressjs/body-parser#bodyparserurlencodedoptions\"><code>bodyParser.urlencoded(options)</code></a></td>\r\n    <td><code>{middlewareHolder}.urlencoded</code></td>\r\n</tr>\r\n<tr>\r\n    <td><code>kettle.middleware.cookieParser</code></td>\r\n    <td><a href=\"https://github.com/expressjs/cookie-parser\">expressjs/cookie-parser</a></td>\r\n    <td>Parses the <code>Cookie</code> header as well as signed cookies via <code>req.secret</code>.</td>\r\n    <td><code>secret</code> and <code>middlewareOptions</code>, forwarded to the two arguments of <a href=\"https://github.com/expressjs/cookie-parser#cookieparsersecret-options\"><code>cookieParser(secret, options)</code></a></td>\r\n    <td>none</td>\r\n</tr>\r\n<tr> \r\n    <td><code>kettle.middleware.session</code></td>\r\n    <td><a href=\"https://github.com/expressjs/session\">expessjs/session</a></td>\r\n    <td>Stores and retrieves <code>req.session</code> from various backends</td>\r\n    <td><code>middlewareOptions</code>, forwarded to <a href=\"https://github.com/expressjs/session#sessionoptions\"><code>session(options)</code></a></td>\r\n    <td><code>{middlewareHolder}.session</code> when using <code>kettle.server.sessionAware</code> server</td>\r\n</tr>\r\n<tr>\r\n    <td><code>kettle.middleware.static</code></td>\r\n    <td><a href=\"https://github.com/expressjs/serve-static\">expressjs/serve-static</a></td>\r\n    <td>Serves static content from the filesystem</td>\r\n    <td><code>root</code> and <code>middlewareOptions</code>, forwarded to the two arguments of <a href=\"https://github.com/expressjs/serve-static#servestaticroot-options\"><code>serveStatic(root, options)</code></a></td>\r\n    <td>none – user must configure on each use</td>\r\n</tr>\r\n<tr>\r\n    <td><code>kettle.middleware.CORS</code></td>\r\n    <td><a href=\"https://github.com/fluid-project/kettle/tree/master/lib/KettleMiddleware.js\">Kettle built-in</a></td>\r\n    <td>Adds <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\">CORS</a> headers to outgoing HTTP request to enable cross-domain access</td>\r\n    <td><code>allowMethods {String}</code> (default <code>\"GET\"</code>), </br><code>origin {String}</code> (default <code>*`), </br> <code>credentials {Boolean}</code> (default <code>true</code>) </br>- \r\n        see <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#The_HTTP_response_headers\">CORS response headers</a></td>\r\n    <td><code>{middlewareHolder}.CORS</code></td>\r\n</tr>\r\n<tr>\r\n    <td><code>kettle.middleware.null</code></td>\r\n    <td><a href=\"https://github.com/fluid-project/kettle/tree/master/lib/KettleMiddleware.js\">Kettle built-in</a></td>\r\n    <td>No-op middleware, useful for overriding and inactivating undesired middleware</td>\r\n    <td>none</td>\r\n    <td><code>{middlewareHolder}.null</code></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n\r\n</div>\r\n\r\nMiddleware which it makes sense to share configuration application-wide is stored in a standard holder of grade `kettle.standardMiddleware` which is descended from the grade `kettle.middlewareHolder` – the \r\ncontext reference `{middlewareHolder}` is recommended for referring to this if required – e.g. `{middlewareHolder}.session`.\r\n\r\n#### Using the static middleware\r\n\r\nHere is an example of mounting a section of a module's filesystem path at a particular URL. In this case, we want to mount the `src` directory of our Infusion module at the global path `/infusion/`, a common\r\nenough requirement. Note that this is done by registering a *handler* just as with any other Kettle request handler, even though in this case the useful request handling function is actually achieved\r\nby the middleware. The only function of the request handler is to serve the 404 message in case the referenced file is not found in the mounted image – in this case, it can refer to the standard builtin handler\r\nnamed `kettle.request.notFoundHandler`. Note that the request handler must declare explicitly that it will handle all URLs under its prefix path by declaring a route of `/*` – this is different to the express\r\nmodel of routing and middleware handling. Kettle will not dispatch a request to a handler unless its route matches all of the incoming URL.\r\n\r\nNote that our static middleware can refer symbolically to the path of any module loaded using Infusion's module system \r\n[`fluid.module.register`](http://docs.fluidproject.org/infusion/development/NodeAPI.html#fluid-module-register-name-basedir-modulerequire-) by means of interpolated terms such as `%infusion`.\r\n\r\nOur config:\r\n\r\n```json\r\n{\r\n    \"type\": \"examples.static.config\",\r\n    \"options\": {\r\n        \"gradeNames\": [\"fluid.component\"],\r\n        \"components\": {\r\n            \"server\": {\r\n                \"type\": \"kettle.server\",\r\n                \"options\": {\r\n                    \"port\": 8081,\r\n                    \"components\": {\r\n                        \"infusionStatic\": {\r\n                            \"type\": \"kettle.middleware.static\",\r\n                            \"options\": {\r\n                                \"root\": \"%infusion/src/\"\r\n                            }\r\n                        },\r\n                        \"app\": {\r\n                            \"type\": \"kettle.app\",\r\n                            \"options\": {\r\n                                \"requestHandlers\": {\r\n                                    \"staticHandler\": {\r\n                                        \"type\": \"examples.static.handler\",\r\n                                        \"prefix\": \"/infusion\",\r\n                                        \"route\": \"/*\",\r\n                                        \"method\": \"get\"\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOur handler:\r\n\r\n```javascript\r\nfluid.defaults(\"examples.static.handler\", {\r\n    gradeNames: \"kettle.request.http\",\r\n    requestMiddleware: {\r\n        \"static\": {\r\n            middleware: \"{server}.infusionStatic\"\r\n        }\r\n    },\r\n    invokers: {\r\n        handleRequest: {\r\n            funcName: \"kettle.request.notFoundHandler\"\r\n        }\r\n    }\r\n});\r\n\r\n```\r\n\r\n\r\n## DataSources\r\n\r\nA DataSource is an Infusion component which meets a simple contract for read/write access to indexed data. DataSource is a simple semantic, broadly the same as that\r\nencoded in [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete), although the current DataSource semantic does not provide explicitly for deletion.\r\n\r\nThe concrete DataSources in Kettle provide support for HTTP endpoints (with a particular variety specialised for accessing CouchDB databases with CRUDlike semantics) as well as the filesystem, with\r\nan emphasis on JSON payloads.\r\n\r\nThe DataSource API is drawn from the following two methods – a read-only DataSource will just implement `get`, and a writeable DataSource will implement both `get` and `set`:\r\n\r\n    /* @param directModel {Object} A JSON structure holding the \"coordinates\" of the state to be read -  \r\n     * this model is morally equivalent to (the substitutable parts of) a file path or URL\r\n     * @param options {Object} [Optional] A JSON structure holding configuration options good for just \r\n     * this request. These will be specially interpreted by the particular concrete grade of DataSource \r\n     * – there are no options valid across all implementations of this grade.\r\n     * @return {Promise} A promise representing successful or unsuccessful resolution of the read state\r\n     */\r\n    dataSource.get(directModel, options);\r\n    /* @param directModel {Object} As for get\r\n     * @param model {Object} The state to be written to the coordinates\r\n     * @param options {Object} [Optional] A JSON structure holding configuration options good for just \r\n     * this request. These will be specially interpreted by the \r\n     * particular concrete grade of DataSource – there are no options valid across all implementations \r\n     * of this grade. For example, a URL DataSource will accept an option `writeMethod` which will \r\n     * allow the user to determine which HTTP method (PUT or POST) will be used to implement the write\r\n     * operation.\r\n     * @return {Promise} A promise representing resolution of the written state,\r\n     * which may also optionally resolve to any returned payload from the write process\r\n     */\r\n    dataSource.set(directModel, model, options);\r\n    \r\n### Simple example of using an HTTP dataSource\r\n\r\nIn this example we define and instantiate a simple HTTP-backed dataSource accepting one argument to configure a URL segment:\r\n\r\n```javascript\r\nvar fluid = require(\"infusion\"),\r\n    kettle = require(\"../../kettle.js\"),\r\n    examples = fluid.registerNamespace(\"examples\");\r\n\r\n\r\nfluid.defaults(\"examples.httpDataSource\", {\r\n    gradeNames: \"kettle.dataSource.URL\",\r\n    url: \"http://jsonplaceholder.typicode.com/posts/%postId\",\r\n    termMap: {\r\n        postId: \"%directPostId\"\r\n    }\r\n});\r\n\r\nvar myDataSource = examples.httpDataSource();\r\nvar promise = myDataSource.get({directPostId: 42});\r\n\r\npromise.then(function (response) {\r\n    console.log(\"Got dataSource response of \", response);\r\n}, function (error) {\r\n    console.error(\"Got dataSource error response of \", error);\r\n});\r\n```\r\n\r\nYou can run this snippet from our code samples by running `node simpleDataSource.js` from [examples/simpleDataSource](examples/simpleDataSource) in our samples area.\r\nThis contacts the useful JSON placeholder API service at [`jsonplaceholder.typicode.com`](http://jsonplaceholder.typicode.com/) to retrieve a small JSON document holding some placeholder text. If you get\r\na 404 or an error, please contact us and we'll update this sample to contact a new service. \r\n\r\nAn interesting element in this snippet is the `termMap` configured as options of our dataSource. This sets up an indirection between the `directModel` supplied as the \r\nargument to the `dataSource.get` call, and the URL issued in the HTTP request. The keys in the `termMap` are interpolation variables in the URL, which in the URL are\r\nprefixed by `%`. The values in the `termMap` represent either\r\n\r\n* Plain values to be interpolated as strings directly into the URL, or\r\n* If the first character of the value in the `termMap` is %, the remainder of the string represents a path which will be dereferenced from the `directModel` argument to the current `set` or `get` request.  \r\n\r\nIn addition, if the term value has the prefix `noencode:`, it will be interpolated without any [URI encoding](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\").\r\n\r\nWe document these configuration options in the next section:\r\n\r\n### Configuration options accepted by `kettle.dataSource.URL`\r\n\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Supported configurable options for a <code>kettle.dataSource.URL</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option Path</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>writable</code></td>\r\n            <td><code>Boolean</code> (default: <code>false</code>)</td>\r\n            <td>If this option is set to <code>true</code>, a <code>set</code> method will be fabricated for this dataSource – otherwise, it will implement only a <code>get</code> method.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>writeMethod</code></td>\r\n            <td><code>String</code> (default: <code>PUT</code>)</td>\r\n            <td>The HTTP method to be used when the <code>set</code> method is operated on this writable DataSource (with <code>writable: true</code>). This defaults to <code>PUT</code> but\r\n            <code>POST</code> is another option. Note that this option can also be supplied within the <code>options</code> argument to the <code>set</code> method itself.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>url</code></td>\r\n            <td><code>String</code></td>\r\n            <td>A URL template, with interpolable elements expressed by terms beginning with the <code>%</code> character, for the URL which will be operated by the <code>get</code> and \r\n            <code>set</code> methods of this dataSource.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>termMap</code></td>\r\n            <td><code>Object</code> (map of <code>String</code> to <code>String</code>)</td>\r\n            <td>A map, of which the keys are some of the interpolation terms held in the <code>url</code> string, and the values will be used to perform the interpolation. If a value begins with <code>%</code>, the remainder of the string \r\n            represents a <a href=\"http://docs.fluidproject.org/infusion/development/FrameworkConcepts.html#el-paths\">path</a> into the <code>directModel</code> argument\r\n            accepted by the <code>get</code> and <code>set</code> methods of the DataSource. By default any such values looked up will be <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\">\r\n            URI Encoded</a> before being interpolated into the URL – unless their value in the termMap is prefixed by the string <code>noencode:</code>.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>notFoundIsEmpty</code></td>\r\n            <td><code>Boolean</code></a> (default: <code>false</code>)</td>\r\n            <td>If this option is set to <code>true</code>, a fetch of a nonexistent resource (that is, a nonexistent file, or an HTTP resource giving a 404) will result in a <code>resolve</code> with an empty\r\n            payload rather than a <code>reject</code> response.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>components.encoding.type</code></td>\r\n            <td><code>String</code> (grade name)</td>\r\n            <td>A <code>kettle.dataSource.URL</code> has a subcomponent named <code>encoding</code> which the user can override in order to choose the encoding used to read and write the <code>model</code>\r\n            object to and from the textual form in persistence. This defaults to <code>kettle.dataSource.encoding.JSON</code>. Other builtin encodings are <code>kettle.dataSource.encoding.formenc</code> operating\r\n            HTML <a href=\"http://www.w3.org/TR/html401/interact/forms.html#didx-applicationx-www-form-urlencoded\">form encoding</code> and <code>kettle.dataSource.encoding.none</code> which applies no encoding.\r\n            More details in <a href=\"#using-content-encodings-with-a-datasource\">Using Content Encodings with a DataSource</a>.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>setResponseTransforms</code></td>\r\n            <td><code>Array of String</code></a> (default: <code>[\"encoding\"]</code>)</td>\r\n            <td>Contains a list of the namespaces of the transform elements (see section <a href=\"#transforming-promise-chains\">transforming promise chains</a> that are to be applied if there is a response payload\r\n            from the <code>set</code> method, which is often the case with an HTTP backend. With a JSON encoding these encoding typically happens symmetrically - with a JSON request one will receive a JSON response - \r\n            however, with other encoding such as <a href=\"http://www.w3.org/TR/html401/interact/forms.html#didx-applicationx-www-form-urlencoded\">form encoding</a> this is often not the case and one might like to\r\n            defeat the effect of trying to decode the HTTP response as a form. In this case, for example, one can override <code>setResponseTransforms</code> with the empty array <code>[]</code>. </td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>charEncoding</code></td>\r\n            <td><code>String</code> (default: <code>utf8</code></td>\r\n            <td>The character encoding of the incoming HTTP stream used to convert its data to characters - this will be sent directly to the <a href=\"https://nodejs.org/api/stream.html#stream_readable_setencoding_encoding\">setEncoding</code> method of\r\n            the response stream</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\nIn addition, a `kettle.dataSource.URL` component will accept any options accepted by node's native \r\n[`http.request`](https://nodejs.org/api/http.html#http_http_request_options_callback) constructor – supported in addition to the above are \r\n`protocol`, `host`, `port`, `headers`, `hostname`, `family`, `localAddress`, `socketPath`, `auth` and `agent`. All of these options will be overriden by options of the same names supplied as the `options` object \r\nsupplied as the last argument to the dataSource's `get` and `set` methods. This is a good way, for example, to send custom HTTP headers along with a URL dataSource request. \r\nNote that any of these component-level options (e.g. `port`, `protocol`, etc.) that can be derived from parsing the `url` option will override the value from the url. Compare this setup with\r\nthe very similar one operated in the testing framework for [`kettle.test.request.http`](#kettle.test.request.http).\r\n\r\n### Configuration options accepted by `kettle.dataSource.file`\r\n\r\nAn alternative dataSource implementation is `kettle.dataSource.file` - this is backed by the node filesystem API to allow files to be read and written in various encodings. The interpolation support based on `termMap`\r\nis very similar to that for `kettle.dataSource.URL`, but with the location template option named `path` representing an absolute filesystem path rather than the `url` property of `kettle.dataSource.URL` representing\r\na URL. \r\n\r\nExactly the same scheme based on the subcomponent named `encoding` can be used to control content encoding for a `kettle.dataSource.file` as for a `kettle.dataSource.URL`. Similarly, `kettle.dataSource.file` supports\r\na further option named `charEncoding` which can select between various of the character encodings supported by node.js.\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Supported configurable options for a <code>kettle.dataSource.file</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option Path</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>writable</code></td>\r\n            <td><code>Boolean</code> (default: <code>false</code>)</td>\r\n            <td>If this option is set to <code>true</code>, a <code>set</code> method will be fabricated for this dataSource – otherwise, it will implement only a <code>get</code> method.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>path</code></td>\r\n            <td><code>String</code></td>\r\n            <td>An (absolute) file path template, with interpolable elements expressed by terms beginning with the <code>%</code> character, for the file which will be read and written the <code>get</code> and \r\n            <code>set</code> methods of this dataSource.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>termMap</code></td>\r\n            <td><code>Object</code> (map of <code>String</code> to <code>String</code>)</td>\r\n            <td>A map, of which the keys are some of the interpolation terms held in the <code>url</code> string, and the values, if prefixed by <code>%</code> are paths into the <code>directModel</code> argument\r\n            accepted by the <code>get</code> and <code>set</code> methods of the DataSource.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>charEncoding</code></td>\r\n            <td><code>String</code> (default: <code>utf8</code></td>\r\n            <td>The character encoding of the file used to convert its data to characters - one of the values supported by the <a href=\"https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options\">node filesystem API</a> - \r\n            values it advertises include <code>utf8</code>, <code>ascii</code> or <code>based64</code>. There is also evidence of support for <code>ucs2</code>.</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\nA helpful mixin grade for `kettle.dataSource.file` is `kettle.dataSource.file.moduleTerms` which will allow interpolation by any module name registered with the Infusion module system \r\n[`fluid.module.register`](http://docs.fluidproject.org/infusion/development/NodeAPI.html#fluid-module-register-name-basedir-modulerequire-) - e.g. `%kettle/tests/data/couchDataSourceError.json`.\r\n \r\n\r\n### Using content encodings with a DataSource\r\n\r\n`kettle.dataSource.URL` has a subcomponent named `encoding` which the user can override in order to choose the content encoding used to convert the model seen at the `get/set` API to the textual (character) form in which it is\r\ntransmitted by the dataSource. The encoding subcomponent will also correctly set the [`Content-Type`](http://www.w3.org/Protocols/rfc1341/4_Content-Type.html) header of the outgoing HTTP request in the\r\ncase of a `set` request. The encoding defaults to a JSON encoding represented by a subcomponent of type `kettle.dataSource.encoding.JSON`. Here is an example of choosing a different encoding to submit \r\n[form encoded](http://www.w3.org/TR/html401/interact/forms.html#didx-applicationx-www-form-urlencoded) data to an HTTP endpoint:\r\n\r\n```javascript\r\nfluid.defaults(\"examples.formDataSource\", {\r\n    gradeNames: \"kettle.dataSource.URL\",\r\n    url: \"http://httpbin.org/post\",\r\n    writable: true,\r\n    writeMethod: \"POST\",\r\n    components: {\r\n        encoding: {\r\n            type: \"kettle.dataSource.encoding.formenc\"\r\n        }\r\n    },\r\n    setResponseTransforms: [] // Do not parse the \"set\" response as formenc - it is in fact JSON\r\n});\r\n\r\nvar myDataSource = examples.formDataSource();\r\nvar promise = myDataSource.set(null, {myField1: \"myValue1\", myField2: \"myValue2\"});\r\n\r\npromise.then(function (response) {\r\n    console.log(\"Got dataSource response of \", JSON.parse(response));\r\n}, function (error) {\r\n    console.error(\"Got dataSource error response of \", error);\r\n});\r\n```\r\n\r\nIn this example we set up a form-encoded, writable dataSource targetted at the popular HTTP testing site `httpbin.org` sending a simple payload encoding two form elements. We use Kettle's built-in form encoding\r\ngrade by configuring an `encoding` subcomponent name `kettle.dataSource.encoding.formenc`. You can try out this\r\nsample live in its place in the [examples directory](examples/formDataSource/formDataSource.js). Note that since this particular endpoint sends a JSON response rather than a form-encoded response,\r\nwe need to defeat the dataSource's attempt to apply the inverse decoding in the response by writing `setResponseTransforms: []`.\r\n\r\n### Built-in content encodings \r\n\r\nKettle features three built-in content encoding grades which can be configured as the subcomponent of a dataSource named `encoding` in order to determine what encoding it applies to models. They are described in this table:\r\n\r\n|Grade name| Encoding type | Content-Type header |\r\n|----------|---------------|----------------|\r\n|`kettle.dataSource.encoding.JSON`|[JSON](http://json.org)|`application/json`|\r\n|`kettle.dataSource.encoding.formenc`|[form encoding](http://www.w3.org/TR/html401/interact/forms.html#didx-applicationx-www-form-urlencoded)|`application/x-www-form-urlencoded`|\r\n|`kettle.dataSource.encoding.none`|No encoding|`text/plain`|\r\n\r\n### Elements of an encoding component\r\n\r\nYou can operate a custom encoding by implementing a grade with the following elements, and using it as the `encoding` subcomponent in place of one of the built-in implementations in the above table:\r\n\r\n|Member name| Type | Description |\r\n|-----------|------|-------------|\r\n|`parse`|`Function (String) -> Any`| Parses the textual form of the data from its encoded form into the in-memory form|\r\n|`render`|`Function (Any) -> String`| Renders the in-memory form of the data into its textual form|\r\n|`contentType`|`String`| Holds the value that should be supplied in the [`Content-Type`](http://www.w3.org/Protocols/rfc1341/4_Content-Type.html) of an outgoing HTTP request whose body is encoded in this form|\r\n\r\n### The `kettle.dataSource.CouchDB` mixin grade\r\n\r\nKettle includes a further mixin grade, `kettle.dataSource.CouchDB`, which is suitable for reading and writing to the [`doc`](http://docs.couchdb.org/en/1.6.1/api/document/common.html) URL space of a [CouchDB](http://couchdb.apache.org/) database.\r\nThis can be applied to either a `kettle.dataSource.URL` or a `kettle.dataSource.file` (the latter clearly only useful for testing purposes).\r\nThis is a basic implementation which simply adapts the base documents in this API to a simple CRUD contract, taking care of:\r\n\r\n* Packaging and unpackaging the special `_id` and `_rev` fields which appear at top level in a CouchDB document\r\n    * The user's document is in fact escaped in a top-level path named `value` to avoid conflicts between its keys and any of those of the CouchDB machinery\r\n* Applying a \"read-before-write\" of the `_rev` field to minimise (but not eliminate completely) the possibility for a Couch-level conflict\r\n\r\nThis grade is not properly tested and still carries some (though very small) risk of a conflict during update – it should be used with caution. Please contact the development team if\r\nyou are interested in improved Couch-specific functionality.\r\n\r\n## Advanced implementation notes on DataSources\r\n\r\nIn this section are a few notes for advanced users of DataSources, who are interested in extending their functionality or else in issuing I/O in Kettle by other means.\r\n\r\n### Transforming promise chains\r\n\r\nThe detailed implementation of the Kettle DataSource is structured around a particular device taken from the Infusion Promises library, the concept of a \"transforming promise chain\". The core\r\nDataSource grade implements two events, `onRead` and and `onWrite`. These events are fired during the `get` and `set` operations of the DataSource, respectively. \r\nThese events are better described as \"pseudoevents\" since they are not fired in the conventional way – rather than each event \r\nlistener receiving the same signature, each instead receives the payload returned by the previous listener – it may then transform this payload and produce its own return in the form\r\nof a promise. Any promise rejection terminates the listener notification chain and propagates the failure to the caller. The virtue of this implementation strategy is that extra stages of processing\r\nfor the DataSource can be inserted and removed from any part of the processing chain by means of supplying suitable event [priorities](http://docs.fluidproject.org/infusion/development/Priorities.html) to\r\nthe event's [listeners](http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html#registering-a-listener-to-an-event). Both the JSON encoding/decoding and CouchDB wrapping/unwrapping\r\nfacilities for the DataSources are implemented in terms of event listeners of this type, rather than in terms of conditional implementation code. This is a powerful and open\r\nimplementation strategy which we plan to extend in future.\r\n\r\n### Callback wrapping in DataSources\r\n\r\nIt's important that Kettle's inbuilt DataSources are used whenever possible when performing I/O from a Kettle application, since it is crucial that any running implementation\r\ncode is always properly contextualised by its appropriate [request component](#request-components). Kettle guarantees that the [IoC context](http://docs.fluidproject.org/infusion/development/Contexts.html) `{request}` \r\nwill always be resolvable onto the appropriate request component from any code executing within that request. If arbitrary callbacks are supplied to node I/O APIs, the code executing in them\r\nwill not be properly contextualised. If for some reason a DataSource is not appropriate, you can manually wrap any callbacks that you use by supplying them to the API `kettle.wrapCallback`.\r\n[Get in touch](#getting-started-and-community) with the dev team if you find yourself in this situation.\r\n\r\n\r\n## Kettle Testing Framework\r\n\r\nThe Kettle testing framework, which can be used for issuing test fixtures against arbitrary HTTP and WebSockets servers, does not depend on\r\nthe rest of Kettle, but is bundled along with it. To get access to the testing framework, after\r\n\r\n    var kettle = require(\"kettle\");\r\n    \r\nthen issue\r\n\r\n    kettle.loadTestingSupport();\r\n    \r\nNote that any users of the Kettle Testing Framework need to list the [node-jqunit](https://www.npmjs.com/package/node-jqunit) module in the `devDependencies` section of their own `package.json`.\r\n    \r\nThe Kettle testing framework flattens out what would be complex callback or promise-laden code into a declarative array of JSON records, each encoding \r\na successive stage in the HTTP or WebSockets conversation. The Kettle testing framework makes use of \r\nInfusion's [IoC Testing Framework](http://docs.fluidproject.org/infusion/development/IoCTestingFramework.html) to encode the test fixtures – you should be familiar with this framework\r\nas well as with the use of Infusion IoC in general before using it.\r\n\r\nThe standard use of the Kettle testing framework involves assembling arrays with alternating active and passive elements using the methods of the\r\ntesting request fixture components `kettle.test.request.http` and `kettle.test.request.ws`. The active records will use the `send` method of `kettle.test.request.http` \r\n(or one of the event firing methods of `kettle.test.request.ws`) to send a request to the server under test, and the passive records will contain a `listener` element\r\nin order to listen to the response from the server and verify that it has a particular form. Before documenting these in detail, we'll construct a simple example,\r\ntesting the simple example application which we developed in the section describing [kettle applications](#kettle-applications).\r\n\r\n```javascript\r\nkettle.loadTestingSupport();\r\n \r\nfluid.registerNamespace(\"examples.tests.simpleConfig\");\r\n\r\nexamples.tests.simpleConfig.testDefs = [{\r\n    name: \"SimpleConfig GET test\",\r\n    expect: 2,\r\n    config: {\r\n        configName: \"examples.simpleConfig\",\r\n        configPath: \"%kettle/examples/simpleConfig\"\r\n    },\r\n    components: {\r\n        getRequest: {\r\n            type: \"kettle.test.request.http\",\r\n            options: {\r\n                path: \"/handlerPath\",\r\n                method: \"GET\"\r\n            }\r\n        }\r\n    },\r\n    sequence: [{\r\n        func: \"{getRequest}.send\"\r\n    }, {\r\n        event: \"{getRequest}.events.onComplete\",\r\n        listener: \"kettle.test.assertJSONResponse\",\r\n        args: {\r\n            message: \"Received GET request from simpleConfig server\",\r\n            string: \"{arguments}.0\",\r\n            request: \"{getRequest}\",\r\n            expected: {\r\n                message: \"GET request received on path /handlerPath\"\r\n            }\r\n        }\r\n    }]\r\n}];\r\n\r\nkettle.test.bootstrapServer(examples.tests.simpleConfig.testDefs);\r\n```\r\n\r\nYou can run a live version of this sample by running\r\n\r\n    node testSimpleConfig.js\r\n    \r\nfrom the [examples/testingSimpleConfig](./examples/testingSimpleConfig) directory of this project.\r\n\r\nThis sample sets up JSON configuration to load the `examples.simpleConfig` application from this module's `examples` directory, and then\r\ndefines a single request test component, named `getRequest`, of type `kettle.test.request.http` which targets its path. The `sequence` section\r\nof the configuration then consists of two elements – the first sends the request, and the second listens for the `onComplete` event fired by\r\nthe request and verifies that the returned payload is exactly as expected.\r\n\r\nNote the use of two particular pieces of Kettle's infrastructure – firstly the use of module-relative paths, where we use the contextualised\r\nreference `%kettle` in order to resolve a file path relative to the base directory of this module, and secondly the Kettle testing assert function\r\n[`kettle.test.assertJSONResponse`](#helper-methods-for-making-assertions-on-oncomplete), which is a helpful all-in-one utility for verifying an HTTP response status code as well as response payload.\r\n\r\n<a id=\"#kettle.test.request.http\"></a>\r\n\r\n### Configuration options available on `kettle.test.request.http`\r\n\r\nTo get a sense of the capabilities of a `kettle.test.request.http`, you should browse node.js's documentation for its [`http.request`](https://nodejs.org/api/http.html#http_http_request_options_callback),\r\nfor which this component is a wrapper. A `kettle.test.request.http` component accepts a number of options configuring its function:\r\n\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Supported configurable options for a <code>kettle.test.request.http</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>path</code></td>\r\n            <td><code>String</code> (default: <code>/</code>)</td>\r\n            <td>The HTTP path to which this request is to be made</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>method</code></td>\r\n            <td><code>String</code> (default: <code>GET</code>)</td>\r\n            <td>The HTTP method to be used to send the request</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>port</code></td>\r\n            <td><code>Number</code> (default: 8081)</td>\r\n            <td>The port number on the server for this request to connect to</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>termMap</code></td>\r\n            <td><code>Object</code> (map of <code>String</code> to <code>String</code>)</td>\r\n            <td>The keys of this map are interpolated terms within the <code>path</code> option (considered as a template where these keys will be prefixed by <code>%</code>). The values will be interpolated directly\r\n            into the path. This structure will be merged with the option of the same name held in the <code>directOptions</code> argument to the request component's <code>send</code> method.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>headers</code></td>\r\n            <td><code>Object/code></td>\r\n            <td>The HTTP headers to be sent with the request</td>\r\n    </tbody>\r\n</table>\r\n\r\nIn addition, the `kettle.test.request.http` component will accept any options accepted by node's native [`http.request`](https://nodejs.org/api/http.html#http_http_request_options_callback) constructor – \r\nsupported in addition to the above are `host`, `hostname`, `family`, `localAddress`, `socketPath`, `auth` and `agent`. All of these options will be overriden by options of the same names supplied as the <code>directOptions</code>\r\nargument to the component's `send` method, described in the following section:\r\n\r\n### Using a `kettle.test.request.http` – the `send` method\r\n\r\nThe primarily useful method on `kettle.test.request.http` is `send`. It accepts two arguments, `(model, directOptions)` :\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Arguments accepted by <code>send</code> method of <code>kettle.test.request.http</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>model</code></td>\r\n            <td><code>Object/String</code> (optional)</td>\r\n            <td>If the HTTP method selected is one accepting a payload (PUT/POST), the payload to be sent by this HTTP request. If this is an <code>Object</code> it will be stringified as JSON, and if it is\r\n            a <code>String</code> it will be sent as the request body directly.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>directOptions</code></td>\r\n            <td><code>Object</code> (optional)</td>\r\n            <td>A set of extra options governing processing of this request. This will be merged with options taken from the component options supplied to the `kettle.test.request.http` component in order\r\n            to arrive at a merged set of per-request options. All of the options described in the previous table are supported here. In particular, entries in <code>headers</code> will be filled in by the implementation – \r\n            the header <code>Content-Length</code> will be populated automatically based on the supplied <code>model</code> to the <code>send</code> method,\r\n            and the header <code>Content-Type</code> will default to <code>application/json</code> if no value is supplied</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n### Listening for a response from `kettle.test.request.http` – the `onComplete` event\r\n\r\nThe response to a `send` request will be notified to listeners of the component's `onComplete` event. Note that since a given `kettle.test.request.http` request component\r\ncan be used to send at most ***one*** request, there can be no confusion about which response is associated which which request. The `onComplete` event fires with the signature `(data, that, parsedData)`, \r\nwhich are described in the following table:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Arguments fired by the <code>onComplete</code> event of <code>kettle.test.request.http</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>data</code></td>\r\n            <td><code>String</code></td>\r\n            <td>The request body received from the HTTP request</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>that</code></td>\r\n            <td><code>Component</code></td>\r\n            <td>The <code>kettle.test.request.http</code> component itself. <it><strong>Note</strong></it>: By the time this event fires, this component will have a member <code>nativeResponse</code> assigned, of type \r\n            <a href=\"https://nodejs.org/api/http.html#http_http_incomingmessage\">http.IncomingMessage</a> – this object can be used to read off various standard pieces of the response to node.js's <code>http.ClientRequest</code>,\r\n            including the HTTP <code>statusCode</code>, headers, etc.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>parsedData</code></td>\r\n            <td><code>Object</code></td>\r\n            <td>This final argument includes various pieces of special information parsed out of the server's response. Currently it contains only two members, `cookies` and `signedCookies`. The former simply contains\r\n            the value of any standard header returned as <code>set-cookie</code> The latter is populated if a <code>cookieJar</code> is configured in this component's tree which is capable of parsing cookies encrypted\r\n            with a \"shared secret\". Consult ths section on use of <a href=\"#using-cookies-with-an-http-testing-request\">cookies</code></a> for more information.</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n### Helper methods for making assertions on onComplete\r\n\r\nThe Kettle testing framework includes two helper functions to simplify the process of making assertions on receiving the `onComplete` event of a `kettle.test.request.http` component. These are\r\nnamed `kettle.test.assertJSONResponse`, which asserts that a successful HTTP response has been received with a particular JSON payload, and `kettle.test.assertErrorResponse`, which asserts\r\nthat an HTTP response was received, whilst checking for various details in the message. Both of these helper functions accept a single complex `options` object encoding all of their requirements,\r\nwhich are documented in the following tables:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Options accepted by the <code>kettle.test.assertJSONResponse</code> helper function</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>string</code></td>\r\n            <td><code>String</code></td>\r\n            <td>The returned request body from the HTTP request</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>request</code></td>\r\n            <td><code>Component</code></td>\r\n            <td>The <code>kettle.test.request.http</code> component which fired the request whose response is being tested</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>statusCode</code></td>\r\n            <td><code>Number</code> (default: 200)</td>\r\n            <td>The expected HTTP status code in ther response</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>expected</code></td>\r\n            <td><code>Object</code></td>\r\n            <td>The expected response payload, encoded as an <code>Object</code> – comparison will be made using a deep equality algorithm (<code>jqUnit.assertDeepEq</code>)</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n<code>kettle.test.assertErrorResponse</code> will expect that the returned HTTP response body will parse as a JSON structure.\r\nIn addition to the checks described in this table, <code>kettle.test.assertErrorResponse</code> will also assert that the returned payload has an `isError` member set to `true`:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Options accepted by the <code>kettle.test.assertErrorResponse</code> helper function</th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>string</code></td>\r\n            <td><code>String</code></td>\r\n            <td>The returned request body from the HTTP request</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>request</code></td>\r\n            <td><code>Component</code></td>\r\n            <td>The <code>kettle.test.request.http</code> component which fired the request whose response is being tested</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>statusCode</code></td>\r\n            <td><code>Number</code> (default: 500)</td>\r\n            <td>The expected HTTP status code in ther response</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>errorTexts</code></td>\r\n            <td><code>String/Array of String</code></td>\r\n            <td>A single <code>String</code> or array of <code>String</code>s which must appear at some index within the <code>message</code> field of the returned JSON response payload</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n### Using cookies with an HTTP testing request\r\n\r\nA framework grade, `kettle.test.request.httpCookie`, derived from `kettle.test.request.http`, will cooperate with a component of type `kettle.test.cookieJar` which must be\r\nconfigured higher in the component tree in order to store and parse cookies. The `kettle.test.cookieJar` is automatically configured as a child of the overall `fluid.test.testCaseHolder`, but\r\nunless the `kettle.test.request.httpCookie` grade is used for the testing request, any returned cookies will be ignored. The `fluid.test.testCaseHolder` accepts an option, <code>secret</code>, which is\r\nbroadcast both to the server and to the cookieJar (using Infusion's [distributeOptions](http://docs.fluidproject.org/infusion/development/IoCSS.html) directive) in order to enable them to cooperate on transmitting signed cookies.\r\nConsult the framework tests at [tests/shared/SessionTestDefs.js](./tests/shared/SessionTestDefs) for examples of how to write a sequence of HTTP fixtures enrolled in a session by means of returned cookies, both signed and unsigned.\r\n\r\nThese tests are also a good example of configuring custom [middleware](#working-with-middleware) into the middle of a request's middleware chain. These tests include a middleware grade named `kettle.tests.middleware.validateSession` which\r\nwill reject requests without a particular piece of populated session data, before processing reaches the request's `requestHandler`.\r\n\r\n### Issuing WebSockets testing fixtures with `kettle.test.request.ws`\r\n\r\nA sibling grade of `kettle.test.request.http` is `kettle.test.request.ws` which will allow the testing of WebSockets endpoints in an analogous way. You should browse the `ws` project's documentation for \r\n[ws.WebSocket](https://github.com/websockets/ws/blob/master/doc/ws.md#new-wswebsocketaddress-protocols-options) for which `kettle.test.request.ws` is a wrapper. As with `kettle.test.request.http`, messages are sent\r\nusing an invoker named `send`, with the difference that method may be invoked any number of times. The options for `kettle.test.request.ws` are as follows:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Supported configurable options for a <code>kettle.test.request.ws</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>path</code></td>\r\n            <td><code>String</code> (default: <code>/</code>)</td>\r\n            <td>The HTTP path to which this request is to be made</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>port</code></td>\r\n            <td><code>Number</code> (default: 8081)</td>\r\n            <td>The port number on the server for this request to connect to</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>sendJSON</code></td>\r\n            <td><code>Boolean</code> (default: <code>true</code>)</td>\r\n            <td>If this is set to <code>true</code>, the argument fired to the component's <code>send</code> method will be encoded as JSON. Otherwise the argument will be sent to <code>websocket.send</code> as is.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>receiveJSON</code></td>\r\n            <td><code>Boolean</code> (default: <code>true</code>)</td>\r\n            <td>If this is set to <code>true</code>, the argument fired to the component's <code>onReceiveMessage</code> method will be encoded as JSON. Otherwise the value will be transmitted as from the WebSocket's <code>message</code> event unchanged.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>webSocketsProtocols</code></td>\r\n            <td><code>String/Array</code></td>\r\n            <td>Forwarded to the <code>protocols</code> constructor argument of <a href=\"https://github.com/websockets/ws/blob/master/doc/ws.md#new-wswebsocketaddress-protocols-options\"><code>ws.WebSocket</code></a></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>termMap</code></td>\r\n            <td><code>Object</code> (map of <code>String</code> to <code>String</code>)</td>\r\n            <td>The keys of this map are interpolated terms within the <code>path</code> option (considered as a template where these keys will be prefixed by <code>%</code>). The values will be interpolated directly\r\n            into the path. This structure will be merged with the option of the same name held in the <code>directOptions</code> argument to the request component's <code>send</code> method.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>headers</code></td>\r\n            <td><code>Object</code></td>\r\n            <td>The HTTP headers to be sent with the request</td>\r\n    </tbody>\r\n</table>\r\n\r\nIn addition to the above options, any option may be supplied that is supported by the `options` argument of [ws.WebSocket](https://github.com/websockets/ws/blob/master/doc/ws.md#new-wswebsocketaddress-protocols-options). \r\nThese include, in addition to the above, `protocol`, `agent`, `protocolVersion`, `hostname`.\r\n\r\n### Events attached to a `kettle.test.request.ws`\r\n\r\nThe following events may be listened to on a `kettle.test.request.ws` component:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Events attached to a <code>kettle.test.request.ws</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Event name</th>\r\n            <th>Arguments</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>onConnect</code></td>\r\n            <td><code>(that: Component)</code>/td>\r\n            <td>Fired when the <code>open</code> event of the underlying <code>ws.WebSocket</code> is fired. This event must be listened to in the fixture sequence before any attempt is made to fire messages from the\r\n            component with <code>send</code></td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>onError</code></td>\r\n            <td><code>(error: Object, that: Component, res: <a href=\"https://nodejs.org/api/http.html#http_http_incomingmessage\">http.IncomingMessage</a>)</td>\r\n            <td>Fired either if an error occurs during the HTTP upgrade process, or if an <code>error</code> event is fired from the <code>ws.WebSocket</code> object once the socket is established. For an error during\r\n            handshake, the <code>error</code> argument will be an object with <code>isError: true</code> and a <code>statusCode</code> field taken from the HTTP statusCode. For an <code>error</code> event, the \r\n            error will be the original error payload.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>onReceiveMessage</code></td>\r\n            <td><code>(data: String/Object, that: Component)</td>\r\n            <td>Fired whenever the underlying <code>ws.WebSocket</code> receives an <code>message</code> event. If the <code>receiveJSON</code> option to the component is <code>true</code> this value will have been\r\n            JSON decoded.\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n### Sending a message using the `send` method of `kettle.test.request.ws`\r\n\r\nThe signature of `kettle.test.request.ws` `send` is the same as that for `kettle.test.request.http`, with a very similar meaning: \r\n\r\nThe primarily useful method on `kettle.test.request.http` is `send`. It accepts two arguments, `(model, directOptions)` :\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th colspan=\"3\">Arguments accepted by <code>send</code> method of <code>kettle.test.request.ws</code></th>\r\n        </tr>\r\n        <tr>\r\n            <th>Option</th>\r\n            <th>Type</th>\r\n            <th>Description</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><code>model</code></td>\r\n            <td><code>Object/String</code></td>\r\n            <td>The payload to be sent with the underlying <code>ws.WebSocket.send</code> call. If the component's <code>sendJSON</code> option is set to <code>true</code> (the default), an Object sent here will be\r\n            automatically JSON-encoded.</td>\r\n        </tr>\r\n        <tr>\r\n            <td><code>directOptions</code></td>\r\n            <td><code>Object</code> (optional)</td>\r\n            <td>These options will be sent as the 2nd argument of <a href=\"https://github.com/websockets/ws/blob/master/doc/ws.md#websocketsenddata-options-callback\"><code>ws.WebSocket.send</code></a></td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n### Issuing session-aware WebSockets requests\r\n\r\nAnalogous with `kettle.test.request.http.cookie`, there is a session-aware variant of the request grade `kettle.test.request.ws`, named `kettle.test.request.ws.cookie`. Its behaviour is identical\r\nwith that of `kettle.test.request.http.cookie`, in particular being able to share access to the same `kettle.test.cookieJar` component to enable a mixed series of HTTP and WebSockets requests\r\nto be contextualised by the same session cookies.\r\n\r\n## Framework tests\r\n\r\nPlease consult the [test cases](./tests) for the framework for more examples of Kettle primitives as well as the Kettle testing framework in action.\r\n",
  "readmeFilename": "README.md",
  "_id": "kettle@1.0.0-dev.20151113T234353Z.121c5db",
  "_shasum": "33d3f87ccc973ce54dcc30bb767e4bc5854037f3",
  "_from": "git://github.com/amb26/kettle.git#aa6410411e65a532fc9dabc3c044e9391649c554",
  "_resolved": "git://github.com/amb26/kettle.git#aa6410411e65a532fc9dabc3c044e9391649c554"
}
